use live_object_sdk::Storage;

const GCOUNTER_KEY: &[u8] = b"gcounter";

// NOTE: all you need to do is attaching #[live_object] to the function you want to export.
// TODO: attach #[live_object] macro here.
pub fn value() -> u32 {
    let storage = Storage::new();

    // TODO: add `live_object_instantiate` to `ramd`. We need to support at least following requests:
    // `live_object_upload`, `live_object_instantiate`, and `live_object_execute`.
    let init = storage.has(GCOUNTER_KEY);
    if !init {
        storage.set(GCOUNTER_KEY, &serde_json::to_vec(&0u32).unwrap());
        return 0;
    }

    let value = storage.get(GCOUNTER_KEY).unwrap();
    let value: u32 = serde_json::from_slice(&value).unwrap();

    value
}

// NOTE: all you need to do is attaching #[live_object] to the function you want to export.
// TODO: attach #[live_object] macro here.
pub fn increment(delta: u32) -> u32 {
    let storage = Storage::new();

    let value = value() + delta;

    storage.set(GCOUNTER_KEY, &serde_json::to_vec(&value).unwrap());

    value
}

// NOTE: below will be generated by #[live_object] macro.
// TODO: implement #[live_object] macro and remove below code.
// Place export functions here to prevent function name collisions.
#[cfg(target_arch = "wasm32")]
mod __export_functions {
    use live_object_sdk::*;

    #[repr(C)]
    #[derive(serde::Deserialize)]
    pub struct ValueInput {}

    #[repr(C)]
    pub struct ValueOutput {
        value: u32,
    }

    impl ValueInput {
        pub fn from_memory_slice_ptr(memory_slice_ptr: u32) -> Self {
            let memory_slice = MemorySlice::from_raw_ptr(memory_slice_ptr as *mut MemorySlice);
            let input_bytes = memory_slice.read();
            serde_json::from_slice(&input_bytes).unwrap()
        }
    }

    impl ValueOutput {
        pub fn into_memory_slice_ptr(output: u32) -> u32 {
            let output_bytes = serde_json::to_vec(&output).unwrap();
            let memory_slice = MemorySlice::new(output_bytes.len() as u32);
            memory_slice.write(&output_bytes);
            memory_slice.into_raw_ptr() as u32
        }
    }

    #[no_mangle]
    pub fn value(memory_slice_ptr: u32) -> u32 {
        let ValueInput {} = ValueInput::from_memory_slice_ptr(memory_slice_ptr);
        let output = super::value();
        ValueOutput::into_memory_slice_ptr(output)
    }

    #[repr(C)]
    #[derive(serde::Deserialize)]
    pub struct IncrementInput {
        delta: u32,
    }

    #[repr(C)]
    pub struct IncrementOutput {
        value: u32,
    }

    impl IncrementInput {
        pub fn from_memory_slice_ptr(memory_slice_ptr: u32) -> Self {
            let memory_slice = MemorySlice::from_raw_ptr(memory_slice_ptr as *mut MemorySlice);
            let input_bytes = memory_slice.read();
            serde_json::from_slice(&input_bytes).unwrap()
        }
    }

    impl IncrementOutput {
        pub fn into_memory_slice_ptr(output: u32) -> u32 {
            let output_bytes = serde_json::to_vec(&output).unwrap();
            let memory_slice = MemorySlice::new(output_bytes.len() as u32);
            memory_slice.write(&output_bytes);
            memory_slice.into_raw_ptr() as u32
        }
    }

    #[no_mangle]
    pub fn increment(memory_slice_ptr: u32) -> u32 {
        let IncrementInput { delta } = IncrementInput::from_memory_slice_ptr(memory_slice_ptr);
        let output = super::increment(delta);
        IncrementOutput::into_memory_slice_ptr(output)
    }
}
